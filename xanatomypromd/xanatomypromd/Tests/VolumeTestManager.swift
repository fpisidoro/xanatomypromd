import Foundation
import Metal
import simd

// MARK: - 3D Volume Test Manager
// Comprehensive testing for VolumeData and MetalVolumeRenderer
// Validates MPR functionality and spatial reconstruction

class VolumeTestManager {
    
    // MARK: - Test Configuration
    
    private static var volumeData: VolumeData?
    private static var volumeRenderer: MetalVolumeRenderer?
    
    // MARK: - Main Test Runner
    
    static func runVolumeTests() {
        print("\nüßä ===========================================")
        print("üßä 3D Volume & MPR Test Suite")
        print("üßä ===========================================\n")
        
        testVolumeDataCreation()
        testSpatialCoordinates()
        testSliceExtraction()
        testMetalVolumeRenderer()
        testMPRGeneration()
        testVolumeStatistics()
        testMemoryPerformance()
        
        print("\n‚úÖ ===========================================")
        print("‚úÖ 3D Volume Tests Complete!")
        print("‚úÖ ===========================================\n")
    }
    
    // MARK: - Individual Tests
    
    static func testVolumeDataCreation() {
        print("üßä TEST: Volume Data Creation from DICOM Series")
        
        let dicomFiles = DICOMTestManager.getDICOMFiles()
        guard dicomFiles.count > 0 else {
            print("   ‚ùå No DICOM files available")
            return
        }
        
        print("   üìÅ Loading \(dicomFiles.count) DICOM files...")
        
        do {
            // Parse all DICOM datasets
            var datasets: [(DICOMDataset, Int)] = []
            
            for (index, fileURL) in dicomFiles.enumerated() {
                let data = try Data(contentsOf: fileURL)
                let dataset = try DICOMParser.parse(data)
                datasets.append((dataset, index))
                
                if index < 3 {
                    print("   üìÑ File \(index): \(fileURL.lastPathComponent)")
                }
            }
            
            // Create volume
            let startTime = CFAbsoluteTimeGetCurrent()
            let volume = try VolumeData(from: datasets)
            let loadTime = CFAbsoluteTimeGetCurrent() - startTime
            
            volumeData = volume
            
            print("   ‚úÖ Volume created successfully")
            print("   ‚è±Ô∏è  Load time: \(String(format: "%.2f", loadTime * 1000))ms")
            
            let stats = volume.getStatistics()
            print("   üìä Volume statistics:")
            print("      üìê Dimensions: \(stats.dimensions)")
            print("      üìè Spacing: \(String(format: "%.2f", stats.spacing.x))√ó\(String(format: "%.2f", stats.spacing.y))√ó\(String(format: "%.2f", stats.spacing.z)) mm")
            print("      üìä Value range: \(stats.minValue) to \(stats.maxValue)")
            print("      üíæ Memory: \(String(format: "%.1f", Double(stats.memoryUsage) / 1024.0 / 1024.0)) MB")
            
        } catch {
            print("   ‚ùå Volume creation failed: \(error)")
        }
        
        print("")
    }
    
    static func testSpatialCoordinates() {
        print("üó∫Ô∏è  TEST: Spatial Coordinate System")
        
        guard let volume = volumeData else {
            print("   ‚ùå No volume data available")
            return
        }
        
        print("   üß≠ Testing coordinate transformations...")
        
        // Test corner coordinates
        let testPoints = [
            ("Origin", SIMD3<Float>(0, 0, 0)),
            ("Center", SIMD3<Float>(Float(volume.dimensions.x/2), Float(volume.dimensions.y/2), Float(volume.dimensions.z/2))),
            ("Max Corner", SIMD3<Float>(Float(volume.dimensions.x-1), Float(volume.dimensions.y-1), Float(volume.dimensions.z-1)))
        ]
        
        for (name, voxelCoord) in testPoints {
            let patientCoord = volume.voxelToPatient(voxelCoord)
            let backToVoxel = volume.patientToVoxel(patientCoord)
            
            let error = simd_length(voxelCoord - backToVoxel)
            
            print("   üìç \(name):")
            print("      Voxel: \(voxelCoord)")
            print("      Patient: \(String(format: "(%.1f, %.1f, %.1f)", patientCoord.x, patientCoord.y, patientCoord.z))")
            print("      Round-trip error: \(String(format: "%.6f", error))")
        }
        
        // Test anatomical directions
        let directions = volume.getAnatomicalDirections()
        print("   üß≠ Anatomical directions:")
        print("      Right: \(directions.right)")
        print("      Anterior: \(directions.anterior)")
        print("      Superior: \(directions.superior)")
        
        print("")
    }
    
    static func testSliceExtraction() {
        print("üî™ TEST: CPU Slice Extraction")
        
        guard let volume = volumeData else {
            print("   ‚ùå No volume data available")
            return
        }
        
        let testSlices = [
            ("Axial Center", MPRPlane.axial, Float(volume.dimensions.z / 2)),
            ("Sagittal Center", MPRPlane.sagittal, Float(volume.dimensions.x / 2)),
            ("Coronal Center", MPRPlane.coronal, Float(volume.dimensions.y / 2))
        ]
        
        for (name, plane, position) in testSlices {
            let startTime = CFAbsoluteTimeGetCurrent()
            
            let sliceData: [Int16]
            let expectedCount: Int
            
            switch plane {
            case .axial:
                sliceData = volume.extractAxialSlice(atZ: position)
                expectedCount = volume.dimensions.x * volume.dimensions.y
            case .sagittal:
                sliceData = volume.extractSagittalSlice(atX: position)
                expectedCount = volume.dimensions.y * volume.dimensions.z
            case .coronal:
                sliceData = volume.extractCoronalSlice(atY: position)
                expectedCount = volume.dimensions.x * volume.dimensions.z
            }
            
            let extractTime = CFAbsoluteTimeGetCurrent() - startTime
            
            print("   üî™ \(name):")
            print("      Expected pixels: \(expectedCount)")
            print("      Extracted pixels: \(sliceData.count)")
            print("      Extraction time: \(String(format: "%.2f", extractTime * 1000))ms")
            
            if !sliceData.isEmpty {
                let minValue = sliceData.min() ?? 0
                let maxValue = sliceData.max() ?? 0
                let avgValue = sliceData.reduce(0) { $0 + Int($1) } / sliceData.count
                
                print("      Value range: \(minValue) to \(maxValue) (avg: \(avgValue))")
                
                // Test for non-zero data
                let nonZeroCount = sliceData.filter { $0 != 0 }.count
                let nonZeroPercent = Double(nonZeroCount) / Double(sliceData.count) * 100
                print("      Non-zero pixels: \(String(format: "%.1f", nonZeroPercent))%")
                
                if nonZeroPercent > 10 {
                    print("      ‚úÖ Slice contains meaningful data")
                } else {
                    print("      ‚ö†Ô∏è  Slice appears mostly empty")
                }
            }
        }
        
        print("")
    }
    
    static func testMetalVolumeRenderer() {
        print("üñ•Ô∏è  TEST: Metal Volume Renderer Initialization")
        
        do {
            let renderer = try MetalVolumeRenderer()
            volumeRenderer = renderer
            
            print("   ‚úÖ MetalVolumeRenderer created successfully")
            
            // Load volume if available
            if let volume = volumeData {
                print("   üì§ Loading volume into Metal texture...")
                
                let startTime = CFAbsoluteTimeGetCurrent()
                try renderer.loadVolume(volume)
                let loadTime = CFAbsoluteTimeGetCurrent() - startTime
                
                print("   ‚úÖ Volume loaded to GPU")
                print("   ‚è±Ô∏è  GPU upload time: \(String(format: "%.2f", loadTime * 1000))ms")
                
                if let info = renderer.getVolumeInfo() {
                    print("   \(info)")
                }
            }
            
        } catch {
            print("   ‚ùå MetalVolumeRenderer initialization failed: \(error)")
        }
        
        print("")
    }
    
    static func testMPRGeneration() {
        print("üé¨ TEST: GPU MPR Slice Generation")
        
        guard let renderer = volumeRenderer else {
            print("   ‚ùå No MetalVolumeRenderer available")
            return
        }
        
        guard renderer.isVolumeLoaded() else {
            print("   ‚ùå No volume loaded in renderer")
            return
        }
        
        let testConfigs = [
            ("Axial Center", MPRPlane.axial, 0.5),
            ("Axial Superior", MPRPlane.axial, 0.8),
            ("Sagittal Center", MPRPlane.sagittal, 0.5),
            ("Sagittal Right", MPRPlane.sagittal, 0.3),
            ("Coronal Center", MPRPlane.coronal, 0.5),
            ("Coronal Anterior", MPRPlane.coronal, 0.7)
        ]
        
        var completedTests = 0
        let totalTests = testConfigs.count
        
        for (name, plane, position) in testConfigs {
            let startTime = CFAbsoluteTimeGetCurrent()
            
            switch plane {
            case .axial:
                renderer.generateAxialSlice(atPosition: Float(position)) { texture in
                    let renderTime = CFAbsoluteTimeGetCurrent() - startTime
                    
                    if let texture = texture {
                        print("   üé¨ \(name): ‚úÖ \(texture.width)√ó\(texture.height) in \(String(format: "%.2f", renderTime * 1000))ms")
                    } else {
                        print("   üé¨ \(name): ‚ùå Failed")
                    }
                    
                    completedTests += 1
                }
                
            case .sagittal:
                renderer.generateSagittalSlice(atPosition: Float(position)) { texture in
                    let renderTime = CFAbsoluteTimeGetCurrent() - startTime
                    
                    if let texture = texture {
                        print("   üé¨ \(name): ‚úÖ \(texture.width)√ó\(texture.height) in \(String(format: "%.2f", renderTime * 1000))ms")
                    } else {
                        print("   üé¨ \(name): ‚ùå Failed")
                    }
                    
                    completedTests += 1
                }
                
            case .coronal:
                renderer.generateCoronalSlice(atPosition: Float(position)) { texture in
                    let renderTime = CFAbsoluteTimeGetCurrent() - startTime
                    
                    if let texture = texture {
                        print("   üé¨ \(name): ‚úÖ \(texture.width)√ó\(texture.height) in \(String(format: "%.2f", renderTime * 1000))ms")
                    } else {
                        print("   üé¨ \(name): ‚ùå Failed")
                    }
                    
                    completedTests += 1
                }
            }
        }
        
        // Wait for async operations to complete
        let timeout = Date().addingTimeInterval(5.0)
        while completedTests < totalTests && Date() < timeout {
            RunLoop.current.run(until: Date().addingTimeInterval(0.1))
        }
        
        if completedTests == totalTests {
            print("   üìä All MPR tests completed successfully")
        } else {
            print("   ‚ö†Ô∏è  Only \(completedTests)/\(totalTests) MPR tests completed")
        }
        
        print("")
    }
    
    static func testVolumeStatistics() {
        print("üìä TEST: Volume Statistics and Analysis")
        
        guard let volume = volumeData else {
            print("   ‚ùå No volume data available")
            return
        }
        
        let stats = volume.getStatistics()
        
        print("   üìà Volume Statistics:")
        print("      üìê Dimensions: \(stats.dimensions.x) √ó \(stats.dimensions.y) √ó \(stats.dimensions.z)")
        print("      üìè Physical size: \(String(format: "%.1f", Float(stats.dimensions.x) * stats.spacing.x))√ó\(String(format: "%.1f", Float(stats.dimensions.y) * stats.spacing.y))√ó\(String(format: "%.1f", Float(stats.dimensions.z) * stats.spacing.z)) mm")
        print("      üìä Intensity range: \(stats.minValue) to \(stats.maxValue) HU")
        print("      üìä Mean intensity: \(String(format: "%.1f", stats.meanValue)) HU")
        print("      üî¢ Total voxels: \(stats.voxelCount)")
        print("      üíæ Memory usage: \(String(format: "%.2f", Double(stats.memoryUsage) / 1024.0 / 1024.0)) MB")
        
        // Test voxel access patterns
        print("   üîç Testing voxel access:")
        
        let testCoords = [
            (0, 0, 0),
            (stats.dimensions.x/2, stats.dimensions.y/2, stats.dimensions.z/2),
            (stats.dimensions.x-1, stats.dimensions.y-1, stats.dimensions.z-1)
        ]
        
        for (x, y, z) in testCoords {
            if let voxel = volume.getVoxel(x: x, y: y, z: z) {
                print("      Voxel[\(x),\(y),\(z)] = \(voxel)")
            } else {
                print("      Voxel[\(x),\(y),\(z)] = out of bounds")
            }
        }
        
        // Test interpolation
        print("   üéØ Testing interpolation:")
        let interpValue = volume.getInterpolatedVoxel(
            x: Float(stats.dimensions.x) * 0.5,
            y: Float(stats.dimensions.y) * 0.5,
            z: Float(stats.dimensions.z) * 0.5
        )
        print("      Center interpolated value: \(String(format: "%.2f", interpValue))")
        
        // Test anatomical position mapping
        print("   üß≠ Testing anatomical positions:")
        for plane in MPRPlane.allCases {
            let centerPos = volume.sliceIndexToAnatomicalPosition(stats.dimensions.z/2, plane: plane)
            print("      \(plane.rawValue) center: \(centerPos)")
        }
        
        print("")
    }
    
    static func testMemoryPerformance() {
        print("‚ö° TEST: Memory and Performance Analysis")
        
        guard let volume = volumeData else {
            print("   ‚ùå No volume data available")
            return
        }
        
        // Memory footprint analysis
        let stats = volume.getStatistics()
        let memoryMB = Double(stats.memoryUsage) / 1024.0 / 1024.0
        
        print("   üíæ Memory Analysis:")
        print("      Raw volume data: \(String(format: "%.2f", memoryMB)) MB")
        print("      Memory per voxel: \(MemoryLayout<Int16>.size) bytes")
        print("      Estimated GPU memory: \(String(format: "%.2f", memoryMB * 1.1)) MB") // Include texture overhead
        
        // Performance benchmarks
        print("   ‚ö° Performance Benchmarks:")
        
        // Benchmark slice extraction
        let iterations = 10
        var totalTime: Double = 0
        
        for i in 0..<iterations {
            let position = Float(i) / Float(iterations - 1) * Float(stats.dimensions.z - 1)
            
            let startTime = CFAbsoluteTimeGetCurrent()
            let _ = volume.extractAxialSlice(atZ: position)
            totalTime += CFAbsoluteTimeGetCurrent() - startTime
        }
        
        let avgExtractionTime = totalTime / Double(iterations) * 1000
        print("      Average slice extraction: \(String(format: "%.2f", avgExtractionTime))ms")
        
        // Benchmark interpolation
        totalTime = 0
        let interpIterations = 1000
        
        let startTime = CFAbsoluteTimeGetCurrent()
        for _ in 0..<interpIterations {
            let x = Float.random(in: 0..<Float(stats.dimensions.x))
            let y = Float.random(in: 0..<Float(stats.dimensions.y))
            let z = Float.random(in: 0..<Float(stats.dimensions.z))
            let _ = volume.getInterpolatedVoxel(x: x, y: y, z: z)
        }
        totalTime = CFAbsoluteTimeGetCurrent() - startTime
        
        let avgInterpolationTime = totalTime / Double(interpIterations) * 1000000 // microseconds
        print("      Average interpolation: \(String(format: "%.2f", avgInterpolationTime))Œºs")
        
        // Memory efficiency analysis
        let theoreticalMin = stats.voxelCount * MemoryLayout<Int16>.size
        let actualUsage = stats.memoryUsage
        let overhead = Double(actualUsage - theoreticalMin) / Double(theoreticalMin) * 100
        
        print("      Memory efficiency: \(String(format: "%.1f", 100.0 - overhead))%")
        print("      Memory overhead: \(String(format: "%.1f", overhead))%")
        
        print("")
    }
    
    // MARK: - Integration Testing
    
    static func testVolumeToPixelDataConversion() {
        print("üîÑ TEST: Volume to PixelData Conversion")
        
        guard let renderer = volumeRenderer else {
            print("   ‚ùå No MetalVolumeRenderer available")
            return
        }
        
        let testCases = [
            ("Axial Center", MPRPlane.axial, 0.5),
            ("Sagittal Center", MPRPlane.sagittal, 0.5),
            ("Coronal Center", MPRPlane.coronal, 0.5)
        ]
        
        for (name, plane, position) in testCases {
            Task {
                if let pixelData = await renderer.mprSliceToPixelData(plane: plane, slicePosition: Float(position)) {
                    print("   üîÑ \(name): ‚úÖ \(pixelData.columns)√ó\(pixelData.rows)")
                    print("      Bits allocated: \(pixelData.bitsAllocated)")
                    print("      Pixel representation: \(pixelData.pixelRepresentation)")
                    print("      Data size: \(pixelData.data.count) bytes")
                    
                    // Test conversion to arrays
                    let pixels = pixelData.toInt16Array()
                    if !pixels.isEmpty {
                        let minVal = pixels.min() ?? 0
                        let maxVal = pixels.max() ?? 0
                        print("      Value range: \(minVal) to \(maxVal)")
                    }
                } else {
                    print("   üîÑ \(name): ‚ùå Conversion failed")
                }
            }
        }
        
        print("")
    }
    
    // MARK: - Utility Methods
    
    static func getLoadedVolume() -> VolumeData? {
        return volumeData
    }
    
    static func getVolumeRenderer() -> MetalVolumeRenderer? {
        return volumeRenderer
    }
    
    static func printVolumeInfo() {
        guard let volume = volumeData else {
            print("‚ùå No volume loaded")
            return
        }
        
        let stats = volume.getStatistics()
        print("""
        
        üìä LOADED VOLUME INFORMATION:
           üìê Dimensions: \(stats.dimensions.x) √ó \(stats.dimensions.y) √ó \(stats.dimensions.z)
           üìè Spacing: \(String(format: "%.2f", stats.spacing.x)) √ó \(String(format: "%.2f", stats.spacing.y)) √ó \(String(format: "%.2f", stats.spacing.z)) mm
           üìä Value range: \(stats.minValue) to \(stats.maxValue) HU
           üíæ Memory: \(String(format: "%.2f", Double(stats.memoryUsage) / 1024.0 / 1024.0)) MB
           üî¢ Voxels: \(stats.voxelCount)
        
        """)
    }
    
    // MARK: - Quick Test Methods
    
    static func runQuickVolumeTests() {
        print("\n‚ö° Quick Volume Tests\n")
        testVolumeDataCreation()
        testMetalVolumeRenderer()
        testMPRGeneration()
        print("‚ö° Quick volume tests complete!\n")
    }
    
    static func testSpecificPlane(_ plane: MPRPlane, position: Float = 0.5) {
        print("\nüéØ Testing \(plane.rawValue) plane at position \(position)\n")
        
        guard let renderer = volumeRenderer else {
            print("‚ùå No renderer available")
            return
        }
        
        let config = MetalVolumeRenderer.MPRConfig(
            plane: plane,
            sliceIndex: position,
            windowCenter: 0.0,
            windowWidth: 2000.0
        )
        
        let startTime = CFAbsoluteTimeGetCurrent()
        
        renderer.generateMPRSlice(config: config) { texture in
            let renderTime = CFAbsoluteTimeGetCurrent() - startTime
            
            if let texture = texture {
                print("‚úÖ \(plane.rawValue) slice generated: \(texture.width)√ó\(texture.height)")
                print("‚è±Ô∏è  Render time: \(String(format: "%.2f", renderTime * 1000))ms")
                print("üé® Pixel format: \(texture.pixelFormat)")
            } else {
                print("‚ùå \(plane.rawValue) slice generation failed")
            }
        }
        
        print("")
    }
}
